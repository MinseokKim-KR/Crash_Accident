# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from my_msgs/ADCTrajectory.msg. Do not edit."""
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import my_msgs.msg

class ADCTrajectory(genpy.Message):
  _md5sum = "05ebe3fe80da9ba7d85947b2055d8e92"
  _type = "my_msgs/ADCTrajectory"
  _has_header = False #flag to mark the presence of a Header object
  _full_text = """my_msgs/Header header
float64 total_path_length
float64 total_path_time
my_msgs/TrajectoryPoint[] trajectory_point
my_msgs/Estop estop
my_msgs/PathPoint path_point
bool is_replan
my_msgs/Chassis_GearPosition gear 
my_msgs/DecisionResult decision
my_msgs/LatencyStats latency_stats
my_msgs/Header routing_header
my_msgs/Planning_Debug debug
================================================================================
MSG: my_msgs/Header
float64 timestamp_sec
string module_name
uint32 sequence_num
uint32 lidar_timestamp
uint32 camera_timestamp
uint32 radar_timestamp
uint32 version
my_msgs/Status status

================================================================================
MSG: my_msgs/Status
int32 error_code

================================================================================
MSG: my_msgs/TrajectoryPoint
my_msgs/PathPoint path_point
float64 v
float64 a
float64 relative_time
================================================================================
MSG: my_msgs/PathPoint
float64 x
float64 y
float64 z
float64 theta
float64 kappa
float64 s
float64 dkappa
float64 ddkappa
string  lane_id
float64 x_derivative
float64 y_derivative
================================================================================
MSG: my_msgs/Estop
bool is_estop
string  reason
================================================================================
MSG: my_msgs/Chassis_GearPosition
int32 GEAR_NEUTRAL
int32 GEAR_DRIVE
int32 GEAR_REVERSE
int32 GEAR_PARKING
int32 GEAR_LOW
int32 GEAR_INVALID
int32 GEAR_NONE
================================================================================
MSG: my_msgs/DecisionResult
my_msgs/MainDecision main_decision
my_msgs/ObjectDecisions object_decision
my_msgs/Common_VehicleSignal vehicle_signal
================================================================================
MSG: my_msgs/MainDecision
my_msgs/MainMissionComplete mission_complete
my_msgs/MainNotReady not_ready
my_msgs/MainParking parking
================================================================================
MSG: my_msgs/MainMissionComplete
my_msgs/PointENU stop_point32
float64 stop_heading
================================================================================
MSG: my_msgs/PointENU
float64 x
float64 y
float64 z

================================================================================
MSG: my_msgs/MainNotReady
string reason
================================================================================
MSG: my_msgs/MainParking

================================================================================
MSG: my_msgs/ObjectDecisions
my_msgs/ObjectDecision[] decisions
================================================================================
MSG: my_msgs/ObjectDecision
string id
int32 perception_id
my_msgs/ObjectDecisionType object_decision
================================================================================
MSG: my_msgs/ObjectDecisionType
my_msgs/ObjectIgnore ignore
my_msgs/ObjectStop stop
my_msgs/ObjectFollow follow
my_msgs/ObjectYield Yield
my_msgs/ObjectOvertake overtake
my_msgs/ObjectNudge nudge
my_msgs/ObjectSidePass sidepass
my_msgs/ObjectAvoid avoid
================================================================================
MSG: my_msgs/ObjectIgnore

================================================================================
MSG: my_msgs/ObjectStop
my_msgs/StopReasonCode reason_code
float64 distance_s
my_msgs/PointENU stop_point32
float64 stop_heading
byte[] wait_for_obstacle
================================================================================
MSG: my_msgs/StopReasonCode
int32 STOP_REASON_HEAD_VEHICLE
int32 STOP_REASON_DESTINATION
int32 STOP_REASON_PEDESTRIAN
int32 STOP_REASON_OBSTACLE
int32 STOP_REASON_PREPARKING
int32 STOP_REASON_SIGNAL
int32 STOP_REASON_STOP_SIGN
int32 STOP_REASON_YIELD_SIGN
int32 STOP_REASON_CLEAR_ZONE
int32 STOP_REASON_CROSSWALK
int32 STOP_REASON_CREEPER
int32 STOP_REASON_REFERENCE_END
int32 STOP_REASON_YELLOW_SIGNAL
int32 STOP_REASON_PULL_OVER
================================================================================
MSG: my_msgs/ObjectFollow
float64 distance_s
my_msgs/PointENU fence_point32
float64 fence_heading
================================================================================
MSG: my_msgs/ObjectYield
float64 distance_s
my_msgs/PointENU fence_point32
float64 fence_heading
float64 time_buffer
================================================================================
MSG: my_msgs/ObjectOvertake
float64 distance_s
my_msgs/PointENU fence_point32
float64 fence_heading
float64 time_buffer
================================================================================
MSG: my_msgs/ObjectNudge
my_msgs/NudgeType type
float64 distance_l
================================================================================
MSG: my_msgs/NudgeType
int32 LEFT_NUDGE
int32 RIGHT_NUDGE
int32 NO_NUDGE
================================================================================
MSG: my_msgs/ObjectSidePass
my_msgs/SidePassType type
================================================================================
MSG: my_msgs/SidePassType
int32 LEFT
int32 RIGHT
================================================================================
MSG: my_msgs/ObjectAvoid

================================================================================
MSG: my_msgs/Common_VehicleSignal
my_msgs/TurnSignal turn_signal
bool high_beam
bool low_beam
bool horn
bool emergency_light
================================================================================
MSG: my_msgs/TurnSignal
int32 TURN_NONE
int32 TURN_LEFT
int32 TURN_RIGHT
================================================================================
MSG: my_msgs/LatencyStats
float64 total_time_ms
float64[] controller_time_ms
bool total_time_exceeded

================================================================================
MSG: my_msgs/Planning_Debug
my_msgs/PlanningData planning_data
================================================================================
MSG: my_msgs/PlanningData
my_msgs/LocalizationEstimate adc_position
my_msgs/Chassis chassis
my_msgs/TrajectoryPoint init_point


================================================================================
MSG: my_msgs/LocalizationEstimate
my_msgs/Header header
my_msgs/Pose pose
float64 measurement_time
================================================================================
MSG: my_msgs/Pose
my_msgs/PointENU position
my_msgs/Quaternion orientation
my_msgs/Point3D linear_velocity
my_msgs/Point3D linear_accelration
my_msgs/Point3D angular_velocity
float64 heading
my_msgs/Point3D linear_acceleration_vrf
my_msgs/Point3D angular_velocity_vrf
my_msgs/Point3D euler_angles
================================================================================
MSG: my_msgs/Quaternion
float64 qx
float64 qy
float64 qz
float64 qw
================================================================================
MSG: my_msgs/Point3D
float64 x
float64 y
float64 z
================================================================================
MSG: my_msgs/Chassis
bool engine_started
float64 engine_rpm
float64 speed_mps
float64 odometer_m
int32 fuel_range_m
float64 throttle_percentage
float64 brake_percentage
float64 steering_percentage
float64 steering_torque_nm
bool parking_brake
bool high_beam_signal
bool low_beam_signal
bool left_turn_signal
bool right_turn_signal
bool horn
bool wiper
bool disengage_status
uint8 driving_mode 
uint8 error_code  
uint8 gear_location  
float64 steering_timestamp
my_msgs/Header header
int32 chassis_error_mask
my_msgs/Common_VehicleSignal signal  
my_msgs/Chassis_ChassisGPS chassis_gps  
my_msgs/Common_EngageAdvise engage_advice  
================================================================================
MSG: my_msgs/Chassis_ChassisGPS
float64 latitude
float64 longitude
bool gps_valid
int32 year
int32 month
int32 day
int32 hours
int32 minutes
int32 seconds
float64 compass_direction
float64 pdop
bool is_gps_fault
bool is_inferred
float64 altitude
float64 heading
float64 hdop
float64 vdop
uint8 quality
int32 num_satellites
float64 gps_speed
================================================================================
MSG: my_msgs/Common_EngageAdvise
uint8 advice
string reason"""
  __slots__ = ['header','total_path_length','total_path_time','trajectory_point','estop','path_point','is_replan','gear','decision','latency_stats','routing_header','debug']
  _slot_types = ['my_msgs/Header','float64','float64','my_msgs/TrajectoryPoint[]','my_msgs/Estop','my_msgs/PathPoint','bool','my_msgs/Chassis_GearPosition','my_msgs/DecisionResult','my_msgs/LatencyStats','my_msgs/Header','my_msgs/Planning_Debug']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       header,total_path_length,total_path_time,trajectory_point,estop,path_point,is_replan,gear,decision,latency_stats,routing_header,debug

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(ADCTrajectory, self).__init__(*args, **kwds)
      #message fields cannot be None, assign default values for those that are
      if self.header is None:
        self.header = my_msgs.msg.Header()
      if self.total_path_length is None:
        self.total_path_length = 0.
      if self.total_path_time is None:
        self.total_path_time = 0.
      if self.trajectory_point is None:
        self.trajectory_point = []
      if self.estop is None:
        self.estop = my_msgs.msg.Estop()
      if self.path_point is None:
        self.path_point = my_msgs.msg.PathPoint()
      if self.is_replan is None:
        self.is_replan = False
      if self.gear is None:
        self.gear = my_msgs.msg.Chassis_GearPosition()
      if self.decision is None:
        self.decision = my_msgs.msg.DecisionResult()
      if self.latency_stats is None:
        self.latency_stats = my_msgs.msg.LatencyStats()
      if self.routing_header is None:
        self.routing_header = my_msgs.msg.Header()
      if self.debug is None:
        self.debug = my_msgs.msg.Planning_Debug()
    else:
      self.header = my_msgs.msg.Header()
      self.total_path_length = 0.
      self.total_path_time = 0.
      self.trajectory_point = []
      self.estop = my_msgs.msg.Estop()
      self.path_point = my_msgs.msg.PathPoint()
      self.is_replan = False
      self.gear = my_msgs.msg.Chassis_GearPosition()
      self.decision = my_msgs.msg.DecisionResult()
      self.latency_stats = my_msgs.msg.LatencyStats()
      self.routing_header = my_msgs.msg.Header()
      self.debug = my_msgs.msg.Planning_Debug()

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      buff.write(_struct_d.pack(self.header.timestamp_sec))
      _x = self.header.module_name
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      if python3:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_struct_5Ii2d.pack(_x.header.sequence_num, _x.header.lidar_timestamp, _x.header.camera_timestamp, _x.header.radar_timestamp, _x.header.version, _x.header.status.error_code, _x.total_path_length, _x.total_path_time))
      length = len(self.trajectory_point)
      buff.write(_struct_I.pack(length))
      for val1 in self.trajectory_point:
        _v1 = val1.path_point
        _x = _v1
        buff.write(_struct_8d.pack(_x.x, _x.y, _x.z, _x.theta, _x.kappa, _x.s, _x.dkappa, _x.ddkappa))
        _x = _v1.lane_id
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = _v1
        buff.write(_struct_2d.pack(_x.x_derivative, _x.y_derivative))
        _x = val1
        buff.write(_struct_3d.pack(_x.v, _x.a, _x.relative_time))
      buff.write(_struct_B.pack(self.estop.is_estop))
      _x = self.estop.reason
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      if python3:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_struct_8d.pack(_x.path_point.x, _x.path_point.y, _x.path_point.z, _x.path_point.theta, _x.path_point.kappa, _x.path_point.s, _x.path_point.dkappa, _x.path_point.ddkappa))
      _x = self.path_point.lane_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      if python3:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_struct_2dB7i4d.pack(_x.path_point.x_derivative, _x.path_point.y_derivative, _x.is_replan, _x.gear.GEAR_NEUTRAL, _x.gear.GEAR_DRIVE, _x.gear.GEAR_REVERSE, _x.gear.GEAR_PARKING, _x.gear.GEAR_LOW, _x.gear.GEAR_INVALID, _x.gear.GEAR_NONE, _x.decision.main_decision.mission_complete.stop_point32.x, _x.decision.main_decision.mission_complete.stop_point32.y, _x.decision.main_decision.mission_complete.stop_point32.z, _x.decision.main_decision.mission_complete.stop_heading))
      _x = self.decision.main_decision.not_ready.reason
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      if python3:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      length = len(self.decision.object_decision.decisions)
      buff.write(_struct_I.pack(length))
      for val1 in self.decision.object_decision.decisions:
        _x = val1.id
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        buff.write(_struct_i.pack(val1.perception_id))
        _v2 = val1.object_decision
        _v3 = _v2.ignore
        pass
        _v4 = _v2.stop
        _v5 = _v4.reason_code
        _x = _v5
        buff.write(_struct_14i.pack(_x.STOP_REASON_HEAD_VEHICLE, _x.STOP_REASON_DESTINATION, _x.STOP_REASON_PEDESTRIAN, _x.STOP_REASON_OBSTACLE, _x.STOP_REASON_PREPARKING, _x.STOP_REASON_SIGNAL, _x.STOP_REASON_STOP_SIGN, _x.STOP_REASON_YIELD_SIGN, _x.STOP_REASON_CLEAR_ZONE, _x.STOP_REASON_CROSSWALK, _x.STOP_REASON_CREEPER, _x.STOP_REASON_REFERENCE_END, _x.STOP_REASON_YELLOW_SIGNAL, _x.STOP_REASON_PULL_OVER))
        buff.write(_struct_d.pack(_v4.distance_s))
        _v6 = _v4.stop_point32
        _x = _v6
        buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
        buff.write(_struct_d.pack(_v4.stop_heading))
        length = len(_v4.wait_for_obstacle)
        buff.write(_struct_I.pack(length))
        pattern = '<%sb'%length
        buff.write(struct.pack(pattern, *_v4.wait_for_obstacle))
        _v7 = _v2.follow
        buff.write(_struct_d.pack(_v7.distance_s))
        _v8 = _v7.fence_point32
        _x = _v8
        buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
        buff.write(_struct_d.pack(_v7.fence_heading))
        _v9 = _v2.Yield
        buff.write(_struct_d.pack(_v9.distance_s))
        _v10 = _v9.fence_point32
        _x = _v10
        buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
        _x = _v9
        buff.write(_struct_2d.pack(_x.fence_heading, _x.time_buffer))
        _v11 = _v2.overtake
        buff.write(_struct_d.pack(_v11.distance_s))
        _v12 = _v11.fence_point32
        _x = _v12
        buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
        _x = _v11
        buff.write(_struct_2d.pack(_x.fence_heading, _x.time_buffer))
        _v13 = _v2.nudge
        _v14 = _v13.type
        _x = _v14
        buff.write(_struct_3i.pack(_x.LEFT_NUDGE, _x.RIGHT_NUDGE, _x.NO_NUDGE))
        buff.write(_struct_d.pack(_v13.distance_l))
        _v15 = _v2.sidepass
        _v16 = _v15.type
        _x = _v16
        buff.write(_struct_2i.pack(_x.LEFT, _x.RIGHT))
        _v17 = _v2.avoid
        pass
      _x = self
      buff.write(_struct_3i4Bd.pack(_x.decision.vehicle_signal.turn_signal.TURN_NONE, _x.decision.vehicle_signal.turn_signal.TURN_LEFT, _x.decision.vehicle_signal.turn_signal.TURN_RIGHT, _x.decision.vehicle_signal.high_beam, _x.decision.vehicle_signal.low_beam, _x.decision.vehicle_signal.horn, _x.decision.vehicle_signal.emergency_light, _x.latency_stats.total_time_ms))
      length = len(self.latency_stats.controller_time_ms)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.latency_stats.controller_time_ms))
      _x = self
      buff.write(_struct_Bd.pack(_x.latency_stats.total_time_exceeded, _x.routing_header.timestamp_sec))
      _x = self.routing_header.module_name
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      if python3:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_struct_5Iid.pack(_x.routing_header.sequence_num, _x.routing_header.lidar_timestamp, _x.routing_header.camera_timestamp, _x.routing_header.radar_timestamp, _x.routing_header.version, _x.routing_header.status.error_code, _x.debug.planning_data.adc_position.header.timestamp_sec))
      _x = self.debug.planning_data.adc_position.header.module_name
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      if python3:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_struct_5Ii27dB3di4d11B2d.pack(_x.debug.planning_data.adc_position.header.sequence_num, _x.debug.planning_data.adc_position.header.lidar_timestamp, _x.debug.planning_data.adc_position.header.camera_timestamp, _x.debug.planning_data.adc_position.header.radar_timestamp, _x.debug.planning_data.adc_position.header.version, _x.debug.planning_data.adc_position.header.status.error_code, _x.debug.planning_data.adc_position.pose.position.x, _x.debug.planning_data.adc_position.pose.position.y, _x.debug.planning_data.adc_position.pose.position.z, _x.debug.planning_data.adc_position.pose.orientation.qx, _x.debug.planning_data.adc_position.pose.orientation.qy, _x.debug.planning_data.adc_position.pose.orientation.qz, _x.debug.planning_data.adc_position.pose.orientation.qw, _x.debug.planning_data.adc_position.pose.linear_velocity.x, _x.debug.planning_data.adc_position.pose.linear_velocity.y, _x.debug.planning_data.adc_position.pose.linear_velocity.z, _x.debug.planning_data.adc_position.pose.linear_accelration.x, _x.debug.planning_data.adc_position.pose.linear_accelration.y, _x.debug.planning_data.adc_position.pose.linear_accelration.z, _x.debug.planning_data.adc_position.pose.angular_velocity.x, _x.debug.planning_data.adc_position.pose.angular_velocity.y, _x.debug.planning_data.adc_position.pose.angular_velocity.z, _x.debug.planning_data.adc_position.pose.heading, _x.debug.planning_data.adc_position.pose.linear_acceleration_vrf.x, _x.debug.planning_data.adc_position.pose.linear_acceleration_vrf.y, _x.debug.planning_data.adc_position.pose.linear_acceleration_vrf.z, _x.debug.planning_data.adc_position.pose.angular_velocity_vrf.x, _x.debug.planning_data.adc_position.pose.angular_velocity_vrf.y, _x.debug.planning_data.adc_position.pose.angular_velocity_vrf.z, _x.debug.planning_data.adc_position.pose.euler_angles.x, _x.debug.planning_data.adc_position.pose.euler_angles.y, _x.debug.planning_data.adc_position.pose.euler_angles.z, _x.debug.planning_data.adc_position.measurement_time, _x.debug.planning_data.chassis.engine_started, _x.debug.planning_data.chassis.engine_rpm, _x.debug.planning_data.chassis.speed_mps, _x.debug.planning_data.chassis.odometer_m, _x.debug.planning_data.chassis.fuel_range_m, _x.debug.planning_data.chassis.throttle_percentage, _x.debug.planning_data.chassis.brake_percentage, _x.debug.planning_data.chassis.steering_percentage, _x.debug.planning_data.chassis.steering_torque_nm, _x.debug.planning_data.chassis.parking_brake, _x.debug.planning_data.chassis.high_beam_signal, _x.debug.planning_data.chassis.low_beam_signal, _x.debug.planning_data.chassis.left_turn_signal, _x.debug.planning_data.chassis.right_turn_signal, _x.debug.planning_data.chassis.horn, _x.debug.planning_data.chassis.wiper, _x.debug.planning_data.chassis.disengage_status, _x.debug.planning_data.chassis.driving_mode, _x.debug.planning_data.chassis.error_code, _x.debug.planning_data.chassis.gear_location, _x.debug.planning_data.chassis.steering_timestamp, _x.debug.planning_data.chassis.header.timestamp_sec))
      _x = self.debug.planning_data.chassis.header.module_name
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      if python3:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_struct_5I5i4B2dB6i2d2B4dBidB.pack(_x.debug.planning_data.chassis.header.sequence_num, _x.debug.planning_data.chassis.header.lidar_timestamp, _x.debug.planning_data.chassis.header.camera_timestamp, _x.debug.planning_data.chassis.header.radar_timestamp, _x.debug.planning_data.chassis.header.version, _x.debug.planning_data.chassis.header.status.error_code, _x.debug.planning_data.chassis.chassis_error_mask, _x.debug.planning_data.chassis.signal.turn_signal.TURN_NONE, _x.debug.planning_data.chassis.signal.turn_signal.TURN_LEFT, _x.debug.planning_data.chassis.signal.turn_signal.TURN_RIGHT, _x.debug.planning_data.chassis.signal.high_beam, _x.debug.planning_data.chassis.signal.low_beam, _x.debug.planning_data.chassis.signal.horn, _x.debug.planning_data.chassis.signal.emergency_light, _x.debug.planning_data.chassis.chassis_gps.latitude, _x.debug.planning_data.chassis.chassis_gps.longitude, _x.debug.planning_data.chassis.chassis_gps.gps_valid, _x.debug.planning_data.chassis.chassis_gps.year, _x.debug.planning_data.chassis.chassis_gps.month, _x.debug.planning_data.chassis.chassis_gps.day, _x.debug.planning_data.chassis.chassis_gps.hours, _x.debug.planning_data.chassis.chassis_gps.minutes, _x.debug.planning_data.chassis.chassis_gps.seconds, _x.debug.planning_data.chassis.chassis_gps.compass_direction, _x.debug.planning_data.chassis.chassis_gps.pdop, _x.debug.planning_data.chassis.chassis_gps.is_gps_fault, _x.debug.planning_data.chassis.chassis_gps.is_inferred, _x.debug.planning_data.chassis.chassis_gps.altitude, _x.debug.planning_data.chassis.chassis_gps.heading, _x.debug.planning_data.chassis.chassis_gps.hdop, _x.debug.planning_data.chassis.chassis_gps.vdop, _x.debug.planning_data.chassis.chassis_gps.quality, _x.debug.planning_data.chassis.chassis_gps.num_satellites, _x.debug.planning_data.chassis.chassis_gps.gps_speed, _x.debug.planning_data.chassis.engage_advice.advice))
      _x = self.debug.planning_data.chassis.engage_advice.reason
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      if python3:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_struct_8d.pack(_x.debug.planning_data.init_point.path_point.x, _x.debug.planning_data.init_point.path_point.y, _x.debug.planning_data.init_point.path_point.z, _x.debug.planning_data.init_point.path_point.theta, _x.debug.planning_data.init_point.path_point.kappa, _x.debug.planning_data.init_point.path_point.s, _x.debug.planning_data.init_point.path_point.dkappa, _x.debug.planning_data.init_point.path_point.ddkappa))
      _x = self.debug.planning_data.init_point.path_point.lane_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      if python3:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_struct_5d.pack(_x.debug.planning_data.init_point.path_point.x_derivative, _x.debug.planning_data.init_point.path_point.y_derivative, _x.debug.planning_data.init_point.v, _x.debug.planning_data.init_point.a, _x.debug.planning_data.init_point.relative_time))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    try:
      if self.header is None:
        self.header = my_msgs.msg.Header()
      if self.trajectory_point is None:
        self.trajectory_point = None
      if self.estop is None:
        self.estop = my_msgs.msg.Estop()
      if self.path_point is None:
        self.path_point = my_msgs.msg.PathPoint()
      if self.gear is None:
        self.gear = my_msgs.msg.Chassis_GearPosition()
      if self.decision is None:
        self.decision = my_msgs.msg.DecisionResult()
      if self.latency_stats is None:
        self.latency_stats = my_msgs.msg.LatencyStats()
      if self.routing_header is None:
        self.routing_header = my_msgs.msg.Header()
      if self.debug is None:
        self.debug = my_msgs.msg.Planning_Debug()
      end = 0
      start = end
      end += 8
      (self.header.timestamp_sec,) = _struct_d.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.header.module_name = str[start:end].decode('utf-8')
      else:
        self.header.module_name = str[start:end]
      _x = self
      start = end
      end += 40
      (_x.header.sequence_num, _x.header.lidar_timestamp, _x.header.camera_timestamp, _x.header.radar_timestamp, _x.header.version, _x.header.status.error_code, _x.total_path_length, _x.total_path_time,) = _struct_5Ii2d.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.trajectory_point = []
      for i in range(0, length):
        val1 = my_msgs.msg.TrajectoryPoint()
        _v18 = val1.path_point
        _x = _v18
        start = end
        end += 64
        (_x.x, _x.y, _x.z, _x.theta, _x.kappa, _x.s, _x.dkappa, _x.ddkappa,) = _struct_8d.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v18.lane_id = str[start:end].decode('utf-8')
        else:
          _v18.lane_id = str[start:end]
        _x = _v18
        start = end
        end += 16
        (_x.x_derivative, _x.y_derivative,) = _struct_2d.unpack(str[start:end])
        _x = val1
        start = end
        end += 24
        (_x.v, _x.a, _x.relative_time,) = _struct_3d.unpack(str[start:end])
        self.trajectory_point.append(val1)
      start = end
      end += 1
      (self.estop.is_estop,) = _struct_B.unpack(str[start:end])
      self.estop.is_estop = bool(self.estop.is_estop)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.estop.reason = str[start:end].decode('utf-8')
      else:
        self.estop.reason = str[start:end]
      _x = self
      start = end
      end += 64
      (_x.path_point.x, _x.path_point.y, _x.path_point.z, _x.path_point.theta, _x.path_point.kappa, _x.path_point.s, _x.path_point.dkappa, _x.path_point.ddkappa,) = _struct_8d.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.path_point.lane_id = str[start:end].decode('utf-8')
      else:
        self.path_point.lane_id = str[start:end]
      _x = self
      start = end
      end += 77
      (_x.path_point.x_derivative, _x.path_point.y_derivative, _x.is_replan, _x.gear.GEAR_NEUTRAL, _x.gear.GEAR_DRIVE, _x.gear.GEAR_REVERSE, _x.gear.GEAR_PARKING, _x.gear.GEAR_LOW, _x.gear.GEAR_INVALID, _x.gear.GEAR_NONE, _x.decision.main_decision.mission_complete.stop_point32.x, _x.decision.main_decision.mission_complete.stop_point32.y, _x.decision.main_decision.mission_complete.stop_point32.z, _x.decision.main_decision.mission_complete.stop_heading,) = _struct_2dB7i4d.unpack(str[start:end])
      self.is_replan = bool(self.is_replan)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.decision.main_decision.not_ready.reason = str[start:end].decode('utf-8')
      else:
        self.decision.main_decision.not_ready.reason = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.decision.object_decision.decisions = []
      for i in range(0, length):
        val1 = my_msgs.msg.ObjectDecision()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.id = str[start:end].decode('utf-8')
        else:
          val1.id = str[start:end]
        start = end
        end += 4
        (val1.perception_id,) = _struct_i.unpack(str[start:end])
        _v19 = val1.object_decision
        _v20 = _v19.ignore
        _v21 = _v19.stop
        _v22 = _v21.reason_code
        _x = _v22
        start = end
        end += 56
        (_x.STOP_REASON_HEAD_VEHICLE, _x.STOP_REASON_DESTINATION, _x.STOP_REASON_PEDESTRIAN, _x.STOP_REASON_OBSTACLE, _x.STOP_REASON_PREPARKING, _x.STOP_REASON_SIGNAL, _x.STOP_REASON_STOP_SIGN, _x.STOP_REASON_YIELD_SIGN, _x.STOP_REASON_CLEAR_ZONE, _x.STOP_REASON_CROSSWALK, _x.STOP_REASON_CREEPER, _x.STOP_REASON_REFERENCE_END, _x.STOP_REASON_YELLOW_SIGNAL, _x.STOP_REASON_PULL_OVER,) = _struct_14i.unpack(str[start:end])
        start = end
        end += 8
        (_v21.distance_s,) = _struct_d.unpack(str[start:end])
        _v23 = _v21.stop_point32
        _x = _v23
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
        start = end
        end += 8
        (_v21.stop_heading,) = _struct_d.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sb'%length
        start = end
        end += struct.calcsize(pattern)
        _v21.wait_for_obstacle = struct.unpack(pattern, str[start:end])
        _v24 = _v19.follow
        start = end
        end += 8
        (_v24.distance_s,) = _struct_d.unpack(str[start:end])
        _v25 = _v24.fence_point32
        _x = _v25
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
        start = end
        end += 8
        (_v24.fence_heading,) = _struct_d.unpack(str[start:end])
        _v26 = _v19.Yield
        start = end
        end += 8
        (_v26.distance_s,) = _struct_d.unpack(str[start:end])
        _v27 = _v26.fence_point32
        _x = _v27
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
        _x = _v26
        start = end
        end += 16
        (_x.fence_heading, _x.time_buffer,) = _struct_2d.unpack(str[start:end])
        _v28 = _v19.overtake
        start = end
        end += 8
        (_v28.distance_s,) = _struct_d.unpack(str[start:end])
        _v29 = _v28.fence_point32
        _x = _v29
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
        _x = _v28
        start = end
        end += 16
        (_x.fence_heading, _x.time_buffer,) = _struct_2d.unpack(str[start:end])
        _v30 = _v19.nudge
        _v31 = _v30.type
        _x = _v31
        start = end
        end += 12
        (_x.LEFT_NUDGE, _x.RIGHT_NUDGE, _x.NO_NUDGE,) = _struct_3i.unpack(str[start:end])
        start = end
        end += 8
        (_v30.distance_l,) = _struct_d.unpack(str[start:end])
        _v32 = _v19.sidepass
        _v33 = _v32.type
        _x = _v33
        start = end
        end += 8
        (_x.LEFT, _x.RIGHT,) = _struct_2i.unpack(str[start:end])
        _v34 = _v19.avoid
        self.decision.object_decision.decisions.append(val1)
      _x = self
      start = end
      end += 24
      (_x.decision.vehicle_signal.turn_signal.TURN_NONE, _x.decision.vehicle_signal.turn_signal.TURN_LEFT, _x.decision.vehicle_signal.turn_signal.TURN_RIGHT, _x.decision.vehicle_signal.high_beam, _x.decision.vehicle_signal.low_beam, _x.decision.vehicle_signal.horn, _x.decision.vehicle_signal.emergency_light, _x.latency_stats.total_time_ms,) = _struct_3i4Bd.unpack(str[start:end])
      self.decision.vehicle_signal.high_beam = bool(self.decision.vehicle_signal.high_beam)
      self.decision.vehicle_signal.low_beam = bool(self.decision.vehicle_signal.low_beam)
      self.decision.vehicle_signal.horn = bool(self.decision.vehicle_signal.horn)
      self.decision.vehicle_signal.emergency_light = bool(self.decision.vehicle_signal.emergency_light)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.latency_stats.controller_time_ms = struct.unpack(pattern, str[start:end])
      _x = self
      start = end
      end += 9
      (_x.latency_stats.total_time_exceeded, _x.routing_header.timestamp_sec,) = _struct_Bd.unpack(str[start:end])
      self.latency_stats.total_time_exceeded = bool(self.latency_stats.total_time_exceeded)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.routing_header.module_name = str[start:end].decode('utf-8')
      else:
        self.routing_header.module_name = str[start:end]
      _x = self
      start = end
      end += 32
      (_x.routing_header.sequence_num, _x.routing_header.lidar_timestamp, _x.routing_header.camera_timestamp, _x.routing_header.radar_timestamp, _x.routing_header.version, _x.routing_header.status.error_code, _x.debug.planning_data.adc_position.header.timestamp_sec,) = _struct_5Iid.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.debug.planning_data.adc_position.header.module_name = str[start:end].decode('utf-8')
      else:
        self.debug.planning_data.adc_position.header.module_name = str[start:end]
      _x = self
      start = end
      end += 328
      (_x.debug.planning_data.adc_position.header.sequence_num, _x.debug.planning_data.adc_position.header.lidar_timestamp, _x.debug.planning_data.adc_position.header.camera_timestamp, _x.debug.planning_data.adc_position.header.radar_timestamp, _x.debug.planning_data.adc_position.header.version, _x.debug.planning_data.adc_position.header.status.error_code, _x.debug.planning_data.adc_position.pose.position.x, _x.debug.planning_data.adc_position.pose.position.y, _x.debug.planning_data.adc_position.pose.position.z, _x.debug.planning_data.adc_position.pose.orientation.qx, _x.debug.planning_data.adc_position.pose.orientation.qy, _x.debug.planning_data.adc_position.pose.orientation.qz, _x.debug.planning_data.adc_position.pose.orientation.qw, _x.debug.planning_data.adc_position.pose.linear_velocity.x, _x.debug.planning_data.adc_position.pose.linear_velocity.y, _x.debug.planning_data.adc_position.pose.linear_velocity.z, _x.debug.planning_data.adc_position.pose.linear_accelration.x, _x.debug.planning_data.adc_position.pose.linear_accelration.y, _x.debug.planning_data.adc_position.pose.linear_accelration.z, _x.debug.planning_data.adc_position.pose.angular_velocity.x, _x.debug.planning_data.adc_position.pose.angular_velocity.y, _x.debug.planning_data.adc_position.pose.angular_velocity.z, _x.debug.planning_data.adc_position.pose.heading, _x.debug.planning_data.adc_position.pose.linear_acceleration_vrf.x, _x.debug.planning_data.adc_position.pose.linear_acceleration_vrf.y, _x.debug.planning_data.adc_position.pose.linear_acceleration_vrf.z, _x.debug.planning_data.adc_position.pose.angular_velocity_vrf.x, _x.debug.planning_data.adc_position.pose.angular_velocity_vrf.y, _x.debug.planning_data.adc_position.pose.angular_velocity_vrf.z, _x.debug.planning_data.adc_position.pose.euler_angles.x, _x.debug.planning_data.adc_position.pose.euler_angles.y, _x.debug.planning_data.adc_position.pose.euler_angles.z, _x.debug.planning_data.adc_position.measurement_time, _x.debug.planning_data.chassis.engine_started, _x.debug.planning_data.chassis.engine_rpm, _x.debug.planning_data.chassis.speed_mps, _x.debug.planning_data.chassis.odometer_m, _x.debug.planning_data.chassis.fuel_range_m, _x.debug.planning_data.chassis.throttle_percentage, _x.debug.planning_data.chassis.brake_percentage, _x.debug.planning_data.chassis.steering_percentage, _x.debug.planning_data.chassis.steering_torque_nm, _x.debug.planning_data.chassis.parking_brake, _x.debug.planning_data.chassis.high_beam_signal, _x.debug.planning_data.chassis.low_beam_signal, _x.debug.planning_data.chassis.left_turn_signal, _x.debug.planning_data.chassis.right_turn_signal, _x.debug.planning_data.chassis.horn, _x.debug.planning_data.chassis.wiper, _x.debug.planning_data.chassis.disengage_status, _x.debug.planning_data.chassis.driving_mode, _x.debug.planning_data.chassis.error_code, _x.debug.planning_data.chassis.gear_location, _x.debug.planning_data.chassis.steering_timestamp, _x.debug.planning_data.chassis.header.timestamp_sec,) = _struct_5Ii27dB3di4d11B2d.unpack(str[start:end])
      self.debug.planning_data.chassis.engine_started = bool(self.debug.planning_data.chassis.engine_started)
      self.debug.planning_data.chassis.parking_brake = bool(self.debug.planning_data.chassis.parking_brake)
      self.debug.planning_data.chassis.high_beam_signal = bool(self.debug.planning_data.chassis.high_beam_signal)
      self.debug.planning_data.chassis.low_beam_signal = bool(self.debug.planning_data.chassis.low_beam_signal)
      self.debug.planning_data.chassis.left_turn_signal = bool(self.debug.planning_data.chassis.left_turn_signal)
      self.debug.planning_data.chassis.right_turn_signal = bool(self.debug.planning_data.chassis.right_turn_signal)
      self.debug.planning_data.chassis.horn = bool(self.debug.planning_data.chassis.horn)
      self.debug.planning_data.chassis.wiper = bool(self.debug.planning_data.chassis.wiper)
      self.debug.planning_data.chassis.disengage_status = bool(self.debug.planning_data.chassis.disengage_status)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.debug.planning_data.chassis.header.module_name = str[start:end].decode('utf-8')
      else:
        self.debug.planning_data.chassis.header.module_name = str[start:end]
      _x = self
      start = end
      end += 149
      (_x.debug.planning_data.chassis.header.sequence_num, _x.debug.planning_data.chassis.header.lidar_timestamp, _x.debug.planning_data.chassis.header.camera_timestamp, _x.debug.planning_data.chassis.header.radar_timestamp, _x.debug.planning_data.chassis.header.version, _x.debug.planning_data.chassis.header.status.error_code, _x.debug.planning_data.chassis.chassis_error_mask, _x.debug.planning_data.chassis.signal.turn_signal.TURN_NONE, _x.debug.planning_data.chassis.signal.turn_signal.TURN_LEFT, _x.debug.planning_data.chassis.signal.turn_signal.TURN_RIGHT, _x.debug.planning_data.chassis.signal.high_beam, _x.debug.planning_data.chassis.signal.low_beam, _x.debug.planning_data.chassis.signal.horn, _x.debug.planning_data.chassis.signal.emergency_light, _x.debug.planning_data.chassis.chassis_gps.latitude, _x.debug.planning_data.chassis.chassis_gps.longitude, _x.debug.planning_data.chassis.chassis_gps.gps_valid, _x.debug.planning_data.chassis.chassis_gps.year, _x.debug.planning_data.chassis.chassis_gps.month, _x.debug.planning_data.chassis.chassis_gps.day, _x.debug.planning_data.chassis.chassis_gps.hours, _x.debug.planning_data.chassis.chassis_gps.minutes, _x.debug.planning_data.chassis.chassis_gps.seconds, _x.debug.planning_data.chassis.chassis_gps.compass_direction, _x.debug.planning_data.chassis.chassis_gps.pdop, _x.debug.planning_data.chassis.chassis_gps.is_gps_fault, _x.debug.planning_data.chassis.chassis_gps.is_inferred, _x.debug.planning_data.chassis.chassis_gps.altitude, _x.debug.planning_data.chassis.chassis_gps.heading, _x.debug.planning_data.chassis.chassis_gps.hdop, _x.debug.planning_data.chassis.chassis_gps.vdop, _x.debug.planning_data.chassis.chassis_gps.quality, _x.debug.planning_data.chassis.chassis_gps.num_satellites, _x.debug.planning_data.chassis.chassis_gps.gps_speed, _x.debug.planning_data.chassis.engage_advice.advice,) = _struct_5I5i4B2dB6i2d2B4dBidB.unpack(str[start:end])
      self.debug.planning_data.chassis.signal.high_beam = bool(self.debug.planning_data.chassis.signal.high_beam)
      self.debug.planning_data.chassis.signal.low_beam = bool(self.debug.planning_data.chassis.signal.low_beam)
      self.debug.planning_data.chassis.signal.horn = bool(self.debug.planning_data.chassis.signal.horn)
      self.debug.planning_data.chassis.signal.emergency_light = bool(self.debug.planning_data.chassis.signal.emergency_light)
      self.debug.planning_data.chassis.chassis_gps.gps_valid = bool(self.debug.planning_data.chassis.chassis_gps.gps_valid)
      self.debug.planning_data.chassis.chassis_gps.is_gps_fault = bool(self.debug.planning_data.chassis.chassis_gps.is_gps_fault)
      self.debug.planning_data.chassis.chassis_gps.is_inferred = bool(self.debug.planning_data.chassis.chassis_gps.is_inferred)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.debug.planning_data.chassis.engage_advice.reason = str[start:end].decode('utf-8')
      else:
        self.debug.planning_data.chassis.engage_advice.reason = str[start:end]
      _x = self
      start = end
      end += 64
      (_x.debug.planning_data.init_point.path_point.x, _x.debug.planning_data.init_point.path_point.y, _x.debug.planning_data.init_point.path_point.z, _x.debug.planning_data.init_point.path_point.theta, _x.debug.planning_data.init_point.path_point.kappa, _x.debug.planning_data.init_point.path_point.s, _x.debug.planning_data.init_point.path_point.dkappa, _x.debug.planning_data.init_point.path_point.ddkappa,) = _struct_8d.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.debug.planning_data.init_point.path_point.lane_id = str[start:end].decode('utf-8')
      else:
        self.debug.planning_data.init_point.path_point.lane_id = str[start:end]
      _x = self
      start = end
      end += 40
      (_x.debug.planning_data.init_point.path_point.x_derivative, _x.debug.planning_data.init_point.path_point.y_derivative, _x.debug.planning_data.init_point.v, _x.debug.planning_data.init_point.a, _x.debug.planning_data.init_point.relative_time,) = _struct_5d.unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e) #most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      buff.write(_struct_d.pack(self.header.timestamp_sec))
      _x = self.header.module_name
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      if python3:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_struct_5Ii2d.pack(_x.header.sequence_num, _x.header.lidar_timestamp, _x.header.camera_timestamp, _x.header.radar_timestamp, _x.header.version, _x.header.status.error_code, _x.total_path_length, _x.total_path_time))
      length = len(self.trajectory_point)
      buff.write(_struct_I.pack(length))
      for val1 in self.trajectory_point:
        _v35 = val1.path_point
        _x = _v35
        buff.write(_struct_8d.pack(_x.x, _x.y, _x.z, _x.theta, _x.kappa, _x.s, _x.dkappa, _x.ddkappa))
        _x = _v35.lane_id
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = _v35
        buff.write(_struct_2d.pack(_x.x_derivative, _x.y_derivative))
        _x = val1
        buff.write(_struct_3d.pack(_x.v, _x.a, _x.relative_time))
      buff.write(_struct_B.pack(self.estop.is_estop))
      _x = self.estop.reason
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      if python3:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_struct_8d.pack(_x.path_point.x, _x.path_point.y, _x.path_point.z, _x.path_point.theta, _x.path_point.kappa, _x.path_point.s, _x.path_point.dkappa, _x.path_point.ddkappa))
      _x = self.path_point.lane_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      if python3:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_struct_2dB7i4d.pack(_x.path_point.x_derivative, _x.path_point.y_derivative, _x.is_replan, _x.gear.GEAR_NEUTRAL, _x.gear.GEAR_DRIVE, _x.gear.GEAR_REVERSE, _x.gear.GEAR_PARKING, _x.gear.GEAR_LOW, _x.gear.GEAR_INVALID, _x.gear.GEAR_NONE, _x.decision.main_decision.mission_complete.stop_point32.x, _x.decision.main_decision.mission_complete.stop_point32.y, _x.decision.main_decision.mission_complete.stop_point32.z, _x.decision.main_decision.mission_complete.stop_heading))
      _x = self.decision.main_decision.not_ready.reason
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      if python3:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      length = len(self.decision.object_decision.decisions)
      buff.write(_struct_I.pack(length))
      for val1 in self.decision.object_decision.decisions:
        _x = val1.id
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        buff.write(_struct_i.pack(val1.perception_id))
        _v36 = val1.object_decision
        _v37 = _v36.ignore
        pass
        _v38 = _v36.stop
        _v39 = _v38.reason_code
        _x = _v39
        buff.write(_struct_14i.pack(_x.STOP_REASON_HEAD_VEHICLE, _x.STOP_REASON_DESTINATION, _x.STOP_REASON_PEDESTRIAN, _x.STOP_REASON_OBSTACLE, _x.STOP_REASON_PREPARKING, _x.STOP_REASON_SIGNAL, _x.STOP_REASON_STOP_SIGN, _x.STOP_REASON_YIELD_SIGN, _x.STOP_REASON_CLEAR_ZONE, _x.STOP_REASON_CROSSWALK, _x.STOP_REASON_CREEPER, _x.STOP_REASON_REFERENCE_END, _x.STOP_REASON_YELLOW_SIGNAL, _x.STOP_REASON_PULL_OVER))
        buff.write(_struct_d.pack(_v38.distance_s))
        _v40 = _v38.stop_point32
        _x = _v40
        buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
        buff.write(_struct_d.pack(_v38.stop_heading))
        length = len(_v38.wait_for_obstacle)
        buff.write(_struct_I.pack(length))
        pattern = '<%sb'%length
        buff.write(_v38.wait_for_obstacle.tostring())
        _v41 = _v36.follow
        buff.write(_struct_d.pack(_v41.distance_s))
        _v42 = _v41.fence_point32
        _x = _v42
        buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
        buff.write(_struct_d.pack(_v41.fence_heading))
        _v43 = _v36.Yield
        buff.write(_struct_d.pack(_v43.distance_s))
        _v44 = _v43.fence_point32
        _x = _v44
        buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
        _x = _v43
        buff.write(_struct_2d.pack(_x.fence_heading, _x.time_buffer))
        _v45 = _v36.overtake
        buff.write(_struct_d.pack(_v45.distance_s))
        _v46 = _v45.fence_point32
        _x = _v46
        buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
        _x = _v45
        buff.write(_struct_2d.pack(_x.fence_heading, _x.time_buffer))
        _v47 = _v36.nudge
        _v48 = _v47.type
        _x = _v48
        buff.write(_struct_3i.pack(_x.LEFT_NUDGE, _x.RIGHT_NUDGE, _x.NO_NUDGE))
        buff.write(_struct_d.pack(_v47.distance_l))
        _v49 = _v36.sidepass
        _v50 = _v49.type
        _x = _v50
        buff.write(_struct_2i.pack(_x.LEFT, _x.RIGHT))
        _v51 = _v36.avoid
        pass
      _x = self
      buff.write(_struct_3i4Bd.pack(_x.decision.vehicle_signal.turn_signal.TURN_NONE, _x.decision.vehicle_signal.turn_signal.TURN_LEFT, _x.decision.vehicle_signal.turn_signal.TURN_RIGHT, _x.decision.vehicle_signal.high_beam, _x.decision.vehicle_signal.low_beam, _x.decision.vehicle_signal.horn, _x.decision.vehicle_signal.emergency_light, _x.latency_stats.total_time_ms))
      length = len(self.latency_stats.controller_time_ms)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.latency_stats.controller_time_ms.tostring())
      _x = self
      buff.write(_struct_Bd.pack(_x.latency_stats.total_time_exceeded, _x.routing_header.timestamp_sec))
      _x = self.routing_header.module_name
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      if python3:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_struct_5Iid.pack(_x.routing_header.sequence_num, _x.routing_header.lidar_timestamp, _x.routing_header.camera_timestamp, _x.routing_header.radar_timestamp, _x.routing_header.version, _x.routing_header.status.error_code, _x.debug.planning_data.adc_position.header.timestamp_sec))
      _x = self.debug.planning_data.adc_position.header.module_name
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      if python3:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_struct_5Ii27dB3di4d11B2d.pack(_x.debug.planning_data.adc_position.header.sequence_num, _x.debug.planning_data.adc_position.header.lidar_timestamp, _x.debug.planning_data.adc_position.header.camera_timestamp, _x.debug.planning_data.adc_position.header.radar_timestamp, _x.debug.planning_data.adc_position.header.version, _x.debug.planning_data.adc_position.header.status.error_code, _x.debug.planning_data.adc_position.pose.position.x, _x.debug.planning_data.adc_position.pose.position.y, _x.debug.planning_data.adc_position.pose.position.z, _x.debug.planning_data.adc_position.pose.orientation.qx, _x.debug.planning_data.adc_position.pose.orientation.qy, _x.debug.planning_data.adc_position.pose.orientation.qz, _x.debug.planning_data.adc_position.pose.orientation.qw, _x.debug.planning_data.adc_position.pose.linear_velocity.x, _x.debug.planning_data.adc_position.pose.linear_velocity.y, _x.debug.planning_data.adc_position.pose.linear_velocity.z, _x.debug.planning_data.adc_position.pose.linear_accelration.x, _x.debug.planning_data.adc_position.pose.linear_accelration.y, _x.debug.planning_data.adc_position.pose.linear_accelration.z, _x.debug.planning_data.adc_position.pose.angular_velocity.x, _x.debug.planning_data.adc_position.pose.angular_velocity.y, _x.debug.planning_data.adc_position.pose.angular_velocity.z, _x.debug.planning_data.adc_position.pose.heading, _x.debug.planning_data.adc_position.pose.linear_acceleration_vrf.x, _x.debug.planning_data.adc_position.pose.linear_acceleration_vrf.y, _x.debug.planning_data.adc_position.pose.linear_acceleration_vrf.z, _x.debug.planning_data.adc_position.pose.angular_velocity_vrf.x, _x.debug.planning_data.adc_position.pose.angular_velocity_vrf.y, _x.debug.planning_data.adc_position.pose.angular_velocity_vrf.z, _x.debug.planning_data.adc_position.pose.euler_angles.x, _x.debug.planning_data.adc_position.pose.euler_angles.y, _x.debug.planning_data.adc_position.pose.euler_angles.z, _x.debug.planning_data.adc_position.measurement_time, _x.debug.planning_data.chassis.engine_started, _x.debug.planning_data.chassis.engine_rpm, _x.debug.planning_data.chassis.speed_mps, _x.debug.planning_data.chassis.odometer_m, _x.debug.planning_data.chassis.fuel_range_m, _x.debug.planning_data.chassis.throttle_percentage, _x.debug.planning_data.chassis.brake_percentage, _x.debug.planning_data.chassis.steering_percentage, _x.debug.planning_data.chassis.steering_torque_nm, _x.debug.planning_data.chassis.parking_brake, _x.debug.planning_data.chassis.high_beam_signal, _x.debug.planning_data.chassis.low_beam_signal, _x.debug.planning_data.chassis.left_turn_signal, _x.debug.planning_data.chassis.right_turn_signal, _x.debug.planning_data.chassis.horn, _x.debug.planning_data.chassis.wiper, _x.debug.planning_data.chassis.disengage_status, _x.debug.planning_data.chassis.driving_mode, _x.debug.planning_data.chassis.error_code, _x.debug.planning_data.chassis.gear_location, _x.debug.planning_data.chassis.steering_timestamp, _x.debug.planning_data.chassis.header.timestamp_sec))
      _x = self.debug.planning_data.chassis.header.module_name
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      if python3:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_struct_5I5i4B2dB6i2d2B4dBidB.pack(_x.debug.planning_data.chassis.header.sequence_num, _x.debug.planning_data.chassis.header.lidar_timestamp, _x.debug.planning_data.chassis.header.camera_timestamp, _x.debug.planning_data.chassis.header.radar_timestamp, _x.debug.planning_data.chassis.header.version, _x.debug.planning_data.chassis.header.status.error_code, _x.debug.planning_data.chassis.chassis_error_mask, _x.debug.planning_data.chassis.signal.turn_signal.TURN_NONE, _x.debug.planning_data.chassis.signal.turn_signal.TURN_LEFT, _x.debug.planning_data.chassis.signal.turn_signal.TURN_RIGHT, _x.debug.planning_data.chassis.signal.high_beam, _x.debug.planning_data.chassis.signal.low_beam, _x.debug.planning_data.chassis.signal.horn, _x.debug.planning_data.chassis.signal.emergency_light, _x.debug.planning_data.chassis.chassis_gps.latitude, _x.debug.planning_data.chassis.chassis_gps.longitude, _x.debug.planning_data.chassis.chassis_gps.gps_valid, _x.debug.planning_data.chassis.chassis_gps.year, _x.debug.planning_data.chassis.chassis_gps.month, _x.debug.planning_data.chassis.chassis_gps.day, _x.debug.planning_data.chassis.chassis_gps.hours, _x.debug.planning_data.chassis.chassis_gps.minutes, _x.debug.planning_data.chassis.chassis_gps.seconds, _x.debug.planning_data.chassis.chassis_gps.compass_direction, _x.debug.planning_data.chassis.chassis_gps.pdop, _x.debug.planning_data.chassis.chassis_gps.is_gps_fault, _x.debug.planning_data.chassis.chassis_gps.is_inferred, _x.debug.planning_data.chassis.chassis_gps.altitude, _x.debug.planning_data.chassis.chassis_gps.heading, _x.debug.planning_data.chassis.chassis_gps.hdop, _x.debug.planning_data.chassis.chassis_gps.vdop, _x.debug.planning_data.chassis.chassis_gps.quality, _x.debug.planning_data.chassis.chassis_gps.num_satellites, _x.debug.planning_data.chassis.chassis_gps.gps_speed, _x.debug.planning_data.chassis.engage_advice.advice))
      _x = self.debug.planning_data.chassis.engage_advice.reason
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      if python3:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_struct_8d.pack(_x.debug.planning_data.init_point.path_point.x, _x.debug.planning_data.init_point.path_point.y, _x.debug.planning_data.init_point.path_point.z, _x.debug.planning_data.init_point.path_point.theta, _x.debug.planning_data.init_point.path_point.kappa, _x.debug.planning_data.init_point.path_point.s, _x.debug.planning_data.init_point.path_point.dkappa, _x.debug.planning_data.init_point.path_point.ddkappa))
      _x = self.debug.planning_data.init_point.path_point.lane_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      if python3:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_struct_5d.pack(_x.debug.planning_data.init_point.path_point.x_derivative, _x.debug.planning_data.init_point.path_point.y_derivative, _x.debug.planning_data.init_point.v, _x.debug.planning_data.init_point.a, _x.debug.planning_data.init_point.relative_time))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    try:
      if self.header is None:
        self.header = my_msgs.msg.Header()
      if self.trajectory_point is None:
        self.trajectory_point = None
      if self.estop is None:
        self.estop = my_msgs.msg.Estop()
      if self.path_point is None:
        self.path_point = my_msgs.msg.PathPoint()
      if self.gear is None:
        self.gear = my_msgs.msg.Chassis_GearPosition()
      if self.decision is None:
        self.decision = my_msgs.msg.DecisionResult()
      if self.latency_stats is None:
        self.latency_stats = my_msgs.msg.LatencyStats()
      if self.routing_header is None:
        self.routing_header = my_msgs.msg.Header()
      if self.debug is None:
        self.debug = my_msgs.msg.Planning_Debug()
      end = 0
      start = end
      end += 8
      (self.header.timestamp_sec,) = _struct_d.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.header.module_name = str[start:end].decode('utf-8')
      else:
        self.header.module_name = str[start:end]
      _x = self
      start = end
      end += 40
      (_x.header.sequence_num, _x.header.lidar_timestamp, _x.header.camera_timestamp, _x.header.radar_timestamp, _x.header.version, _x.header.status.error_code, _x.total_path_length, _x.total_path_time,) = _struct_5Ii2d.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.trajectory_point = []
      for i in range(0, length):
        val1 = my_msgs.msg.TrajectoryPoint()
        _v52 = val1.path_point
        _x = _v52
        start = end
        end += 64
        (_x.x, _x.y, _x.z, _x.theta, _x.kappa, _x.s, _x.dkappa, _x.ddkappa,) = _struct_8d.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v52.lane_id = str[start:end].decode('utf-8')
        else:
          _v52.lane_id = str[start:end]
        _x = _v52
        start = end
        end += 16
        (_x.x_derivative, _x.y_derivative,) = _struct_2d.unpack(str[start:end])
        _x = val1
        start = end
        end += 24
        (_x.v, _x.a, _x.relative_time,) = _struct_3d.unpack(str[start:end])
        self.trajectory_point.append(val1)
      start = end
      end += 1
      (self.estop.is_estop,) = _struct_B.unpack(str[start:end])
      self.estop.is_estop = bool(self.estop.is_estop)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.estop.reason = str[start:end].decode('utf-8')
      else:
        self.estop.reason = str[start:end]
      _x = self
      start = end
      end += 64
      (_x.path_point.x, _x.path_point.y, _x.path_point.z, _x.path_point.theta, _x.path_point.kappa, _x.path_point.s, _x.path_point.dkappa, _x.path_point.ddkappa,) = _struct_8d.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.path_point.lane_id = str[start:end].decode('utf-8')
      else:
        self.path_point.lane_id = str[start:end]
      _x = self
      start = end
      end += 77
      (_x.path_point.x_derivative, _x.path_point.y_derivative, _x.is_replan, _x.gear.GEAR_NEUTRAL, _x.gear.GEAR_DRIVE, _x.gear.GEAR_REVERSE, _x.gear.GEAR_PARKING, _x.gear.GEAR_LOW, _x.gear.GEAR_INVALID, _x.gear.GEAR_NONE, _x.decision.main_decision.mission_complete.stop_point32.x, _x.decision.main_decision.mission_complete.stop_point32.y, _x.decision.main_decision.mission_complete.stop_point32.z, _x.decision.main_decision.mission_complete.stop_heading,) = _struct_2dB7i4d.unpack(str[start:end])
      self.is_replan = bool(self.is_replan)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.decision.main_decision.not_ready.reason = str[start:end].decode('utf-8')
      else:
        self.decision.main_decision.not_ready.reason = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.decision.object_decision.decisions = []
      for i in range(0, length):
        val1 = my_msgs.msg.ObjectDecision()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.id = str[start:end].decode('utf-8')
        else:
          val1.id = str[start:end]
        start = end
        end += 4
        (val1.perception_id,) = _struct_i.unpack(str[start:end])
        _v53 = val1.object_decision
        _v54 = _v53.ignore
        _v55 = _v53.stop
        _v56 = _v55.reason_code
        _x = _v56
        start = end
        end += 56
        (_x.STOP_REASON_HEAD_VEHICLE, _x.STOP_REASON_DESTINATION, _x.STOP_REASON_PEDESTRIAN, _x.STOP_REASON_OBSTACLE, _x.STOP_REASON_PREPARKING, _x.STOP_REASON_SIGNAL, _x.STOP_REASON_STOP_SIGN, _x.STOP_REASON_YIELD_SIGN, _x.STOP_REASON_CLEAR_ZONE, _x.STOP_REASON_CROSSWALK, _x.STOP_REASON_CREEPER, _x.STOP_REASON_REFERENCE_END, _x.STOP_REASON_YELLOW_SIGNAL, _x.STOP_REASON_PULL_OVER,) = _struct_14i.unpack(str[start:end])
        start = end
        end += 8
        (_v55.distance_s,) = _struct_d.unpack(str[start:end])
        _v57 = _v55.stop_point32
        _x = _v57
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
        start = end
        end += 8
        (_v55.stop_heading,) = _struct_d.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sb'%length
        start = end
        end += struct.calcsize(pattern)
        _v55.wait_for_obstacle = numpy.frombuffer(str[start:end], dtype=numpy.int8, count=length)
        _v58 = _v53.follow
        start = end
        end += 8
        (_v58.distance_s,) = _struct_d.unpack(str[start:end])
        _v59 = _v58.fence_point32
        _x = _v59
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
        start = end
        end += 8
        (_v58.fence_heading,) = _struct_d.unpack(str[start:end])
        _v60 = _v53.Yield
        start = end
        end += 8
        (_v60.distance_s,) = _struct_d.unpack(str[start:end])
        _v61 = _v60.fence_point32
        _x = _v61
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
        _x = _v60
        start = end
        end += 16
        (_x.fence_heading, _x.time_buffer,) = _struct_2d.unpack(str[start:end])
        _v62 = _v53.overtake
        start = end
        end += 8
        (_v62.distance_s,) = _struct_d.unpack(str[start:end])
        _v63 = _v62.fence_point32
        _x = _v63
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
        _x = _v62
        start = end
        end += 16
        (_x.fence_heading, _x.time_buffer,) = _struct_2d.unpack(str[start:end])
        _v64 = _v53.nudge
        _v65 = _v64.type
        _x = _v65
        start = end
        end += 12
        (_x.LEFT_NUDGE, _x.RIGHT_NUDGE, _x.NO_NUDGE,) = _struct_3i.unpack(str[start:end])
        start = end
        end += 8
        (_v64.distance_l,) = _struct_d.unpack(str[start:end])
        _v66 = _v53.sidepass
        _v67 = _v66.type
        _x = _v67
        start = end
        end += 8
        (_x.LEFT, _x.RIGHT,) = _struct_2i.unpack(str[start:end])
        _v68 = _v53.avoid
        self.decision.object_decision.decisions.append(val1)
      _x = self
      start = end
      end += 24
      (_x.decision.vehicle_signal.turn_signal.TURN_NONE, _x.decision.vehicle_signal.turn_signal.TURN_LEFT, _x.decision.vehicle_signal.turn_signal.TURN_RIGHT, _x.decision.vehicle_signal.high_beam, _x.decision.vehicle_signal.low_beam, _x.decision.vehicle_signal.horn, _x.decision.vehicle_signal.emergency_light, _x.latency_stats.total_time_ms,) = _struct_3i4Bd.unpack(str[start:end])
      self.decision.vehicle_signal.high_beam = bool(self.decision.vehicle_signal.high_beam)
      self.decision.vehicle_signal.low_beam = bool(self.decision.vehicle_signal.low_beam)
      self.decision.vehicle_signal.horn = bool(self.decision.vehicle_signal.horn)
      self.decision.vehicle_signal.emergency_light = bool(self.decision.vehicle_signal.emergency_light)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.latency_stats.controller_time_ms = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      _x = self
      start = end
      end += 9
      (_x.latency_stats.total_time_exceeded, _x.routing_header.timestamp_sec,) = _struct_Bd.unpack(str[start:end])
      self.latency_stats.total_time_exceeded = bool(self.latency_stats.total_time_exceeded)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.routing_header.module_name = str[start:end].decode('utf-8')
      else:
        self.routing_header.module_name = str[start:end]
      _x = self
      start = end
      end += 32
      (_x.routing_header.sequence_num, _x.routing_header.lidar_timestamp, _x.routing_header.camera_timestamp, _x.routing_header.radar_timestamp, _x.routing_header.version, _x.routing_header.status.error_code, _x.debug.planning_data.adc_position.header.timestamp_sec,) = _struct_5Iid.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.debug.planning_data.adc_position.header.module_name = str[start:end].decode('utf-8')
      else:
        self.debug.planning_data.adc_position.header.module_name = str[start:end]
      _x = self
      start = end
      end += 328
      (_x.debug.planning_data.adc_position.header.sequence_num, _x.debug.planning_data.adc_position.header.lidar_timestamp, _x.debug.planning_data.adc_position.header.camera_timestamp, _x.debug.planning_data.adc_position.header.radar_timestamp, _x.debug.planning_data.adc_position.header.version, _x.debug.planning_data.adc_position.header.status.error_code, _x.debug.planning_data.adc_position.pose.position.x, _x.debug.planning_data.adc_position.pose.position.y, _x.debug.planning_data.adc_position.pose.position.z, _x.debug.planning_data.adc_position.pose.orientation.qx, _x.debug.planning_data.adc_position.pose.orientation.qy, _x.debug.planning_data.adc_position.pose.orientation.qz, _x.debug.planning_data.adc_position.pose.orientation.qw, _x.debug.planning_data.adc_position.pose.linear_velocity.x, _x.debug.planning_data.adc_position.pose.linear_velocity.y, _x.debug.planning_data.adc_position.pose.linear_velocity.z, _x.debug.planning_data.adc_position.pose.linear_accelration.x, _x.debug.planning_data.adc_position.pose.linear_accelration.y, _x.debug.planning_data.adc_position.pose.linear_accelration.z, _x.debug.planning_data.adc_position.pose.angular_velocity.x, _x.debug.planning_data.adc_position.pose.angular_velocity.y, _x.debug.planning_data.adc_position.pose.angular_velocity.z, _x.debug.planning_data.adc_position.pose.heading, _x.debug.planning_data.adc_position.pose.linear_acceleration_vrf.x, _x.debug.planning_data.adc_position.pose.linear_acceleration_vrf.y, _x.debug.planning_data.adc_position.pose.linear_acceleration_vrf.z, _x.debug.planning_data.adc_position.pose.angular_velocity_vrf.x, _x.debug.planning_data.adc_position.pose.angular_velocity_vrf.y, _x.debug.planning_data.adc_position.pose.angular_velocity_vrf.z, _x.debug.planning_data.adc_position.pose.euler_angles.x, _x.debug.planning_data.adc_position.pose.euler_angles.y, _x.debug.planning_data.adc_position.pose.euler_angles.z, _x.debug.planning_data.adc_position.measurement_time, _x.debug.planning_data.chassis.engine_started, _x.debug.planning_data.chassis.engine_rpm, _x.debug.planning_data.chassis.speed_mps, _x.debug.planning_data.chassis.odometer_m, _x.debug.planning_data.chassis.fuel_range_m, _x.debug.planning_data.chassis.throttle_percentage, _x.debug.planning_data.chassis.brake_percentage, _x.debug.planning_data.chassis.steering_percentage, _x.debug.planning_data.chassis.steering_torque_nm, _x.debug.planning_data.chassis.parking_brake, _x.debug.planning_data.chassis.high_beam_signal, _x.debug.planning_data.chassis.low_beam_signal, _x.debug.planning_data.chassis.left_turn_signal, _x.debug.planning_data.chassis.right_turn_signal, _x.debug.planning_data.chassis.horn, _x.debug.planning_data.chassis.wiper, _x.debug.planning_data.chassis.disengage_status, _x.debug.planning_data.chassis.driving_mode, _x.debug.planning_data.chassis.error_code, _x.debug.planning_data.chassis.gear_location, _x.debug.planning_data.chassis.steering_timestamp, _x.debug.planning_data.chassis.header.timestamp_sec,) = _struct_5Ii27dB3di4d11B2d.unpack(str[start:end])
      self.debug.planning_data.chassis.engine_started = bool(self.debug.planning_data.chassis.engine_started)
      self.debug.planning_data.chassis.parking_brake = bool(self.debug.planning_data.chassis.parking_brake)
      self.debug.planning_data.chassis.high_beam_signal = bool(self.debug.planning_data.chassis.high_beam_signal)
      self.debug.planning_data.chassis.low_beam_signal = bool(self.debug.planning_data.chassis.low_beam_signal)
      self.debug.planning_data.chassis.left_turn_signal = bool(self.debug.planning_data.chassis.left_turn_signal)
      self.debug.planning_data.chassis.right_turn_signal = bool(self.debug.planning_data.chassis.right_turn_signal)
      self.debug.planning_data.chassis.horn = bool(self.debug.planning_data.chassis.horn)
      self.debug.planning_data.chassis.wiper = bool(self.debug.planning_data.chassis.wiper)
      self.debug.planning_data.chassis.disengage_status = bool(self.debug.planning_data.chassis.disengage_status)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.debug.planning_data.chassis.header.module_name = str[start:end].decode('utf-8')
      else:
        self.debug.planning_data.chassis.header.module_name = str[start:end]
      _x = self
      start = end
      end += 149
      (_x.debug.planning_data.chassis.header.sequence_num, _x.debug.planning_data.chassis.header.lidar_timestamp, _x.debug.planning_data.chassis.header.camera_timestamp, _x.debug.planning_data.chassis.header.radar_timestamp, _x.debug.planning_data.chassis.header.version, _x.debug.planning_data.chassis.header.status.error_code, _x.debug.planning_data.chassis.chassis_error_mask, _x.debug.planning_data.chassis.signal.turn_signal.TURN_NONE, _x.debug.planning_data.chassis.signal.turn_signal.TURN_LEFT, _x.debug.planning_data.chassis.signal.turn_signal.TURN_RIGHT, _x.debug.planning_data.chassis.signal.high_beam, _x.debug.planning_data.chassis.signal.low_beam, _x.debug.planning_data.chassis.signal.horn, _x.debug.planning_data.chassis.signal.emergency_light, _x.debug.planning_data.chassis.chassis_gps.latitude, _x.debug.planning_data.chassis.chassis_gps.longitude, _x.debug.planning_data.chassis.chassis_gps.gps_valid, _x.debug.planning_data.chassis.chassis_gps.year, _x.debug.planning_data.chassis.chassis_gps.month, _x.debug.planning_data.chassis.chassis_gps.day, _x.debug.planning_data.chassis.chassis_gps.hours, _x.debug.planning_data.chassis.chassis_gps.minutes, _x.debug.planning_data.chassis.chassis_gps.seconds, _x.debug.planning_data.chassis.chassis_gps.compass_direction, _x.debug.planning_data.chassis.chassis_gps.pdop, _x.debug.planning_data.chassis.chassis_gps.is_gps_fault, _x.debug.planning_data.chassis.chassis_gps.is_inferred, _x.debug.planning_data.chassis.chassis_gps.altitude, _x.debug.planning_data.chassis.chassis_gps.heading, _x.debug.planning_data.chassis.chassis_gps.hdop, _x.debug.planning_data.chassis.chassis_gps.vdop, _x.debug.planning_data.chassis.chassis_gps.quality, _x.debug.planning_data.chassis.chassis_gps.num_satellites, _x.debug.planning_data.chassis.chassis_gps.gps_speed, _x.debug.planning_data.chassis.engage_advice.advice,) = _struct_5I5i4B2dB6i2d2B4dBidB.unpack(str[start:end])
      self.debug.planning_data.chassis.signal.high_beam = bool(self.debug.planning_data.chassis.signal.high_beam)
      self.debug.planning_data.chassis.signal.low_beam = bool(self.debug.planning_data.chassis.signal.low_beam)
      self.debug.planning_data.chassis.signal.horn = bool(self.debug.planning_data.chassis.signal.horn)
      self.debug.planning_data.chassis.signal.emergency_light = bool(self.debug.planning_data.chassis.signal.emergency_light)
      self.debug.planning_data.chassis.chassis_gps.gps_valid = bool(self.debug.planning_data.chassis.chassis_gps.gps_valid)
      self.debug.planning_data.chassis.chassis_gps.is_gps_fault = bool(self.debug.planning_data.chassis.chassis_gps.is_gps_fault)
      self.debug.planning_data.chassis.chassis_gps.is_inferred = bool(self.debug.planning_data.chassis.chassis_gps.is_inferred)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.debug.planning_data.chassis.engage_advice.reason = str[start:end].decode('utf-8')
      else:
        self.debug.planning_data.chassis.engage_advice.reason = str[start:end]
      _x = self
      start = end
      end += 64
      (_x.debug.planning_data.init_point.path_point.x, _x.debug.planning_data.init_point.path_point.y, _x.debug.planning_data.init_point.path_point.z, _x.debug.planning_data.init_point.path_point.theta, _x.debug.planning_data.init_point.path_point.kappa, _x.debug.planning_data.init_point.path_point.s, _x.debug.planning_data.init_point.path_point.dkappa, _x.debug.planning_data.init_point.path_point.ddkappa,) = _struct_8d.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.debug.planning_data.init_point.path_point.lane_id = str[start:end].decode('utf-8')
      else:
        self.debug.planning_data.init_point.path_point.lane_id = str[start:end]
      _x = self
      start = end
      end += 40
      (_x.debug.planning_data.init_point.path_point.x_derivative, _x.debug.planning_data.init_point.path_point.y_derivative, _x.debug.planning_data.init_point.v, _x.debug.planning_data.init_point.a, _x.debug.planning_data.init_point.relative_time,) = _struct_5d.unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e) #most likely buffer underfill

_struct_I = genpy.struct_I
_struct_Bd = struct.Struct("<Bd")
_struct_5Iid = struct.Struct("<5Iid")
_struct_B = struct.Struct("<B")
_struct_5Ii27dB3di4d11B2d = struct.Struct("<5Ii27dB3di4d11B2d")
_struct_d = struct.Struct("<d")
_struct_2dB7i4d = struct.Struct("<2dB7i4d")
_struct_i = struct.Struct("<i")
_struct_3i4Bd = struct.Struct("<3i4Bd")
_struct_8d = struct.Struct("<8d")
_struct_2d = struct.Struct("<2d")
_struct_3i = struct.Struct("<3i")
_struct_5I5i4B2dB6i2d2B4dBidB = struct.Struct("<5I5i4B2dB6i2d2B4dBidB")
_struct_5Ii2d = struct.Struct("<5Ii2d")
_struct_5d = struct.Struct("<5d")
_struct_14i = struct.Struct("<14i")
_struct_2i = struct.Struct("<2i")
_struct_3d = struct.Struct("<3d")
